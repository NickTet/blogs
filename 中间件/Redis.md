- Key过期策略

```
主动删除：TTL 定时器
被动删除：访问key的时候，才去检查key是否过期，过期就删除
定期删除：每隔一段时间,去内存中采样检查一定数量的key(默认5，越大越接近传统LRU)，如果过期就删除
Redis是被动+定期
设置了过期时间的key和没设置过期时间的key分开存储

全未设key过期：当set值得时候，检查发现redis内存达到最大设置的值，则去掉一个释放内存空间的方法
释放规则算法：
LRU：least recently used最近最少使用，变种LRU，从数据库随机选择指定数目的key(默认5，越大越接近传统LRU)，然后将热度最低的key删除，热度即redisObject中lru属性上次被访问时间和当前全局时钟的差值
    全局时钟是定时器每100Ms更新一次，故最大延迟100Ms
LFU：least frequently used 一定时间内，使用频率最低。通过计数器，访问加1，不访问会衰减
Random：随机
```

- redis持久化

```
优先aof
RDB快照
含义：redis dataBase，将内存中所有的数据生成dump.rdb文件，可通过参数配置是否开启文件压缩和checkSum
触发条件：
    配置文件save seconds changes -> 多少秒内有多少改变，就会触发生成快照
    flushall命令、关机的时候
    save命令、bgsave命令

AOF：
含义：存储操作指令、rewrite重写，可以减小aof文件的大小
触发条件：always、everysecond、no(操作系统自己控制)、
重写条件：
    auto-aof-rewrite-peceentage 当前aof文件达到上一次aof大小的比例
    auto-aof-rewrite-min-size 最小重写文件大小
    重写是fork一个子线程重写
```
- 主从

```
slave端每隔一秒检测是否自己是另外一个实例的从节点，是的话，执行以下步骤
1、根据配置文件或者命令行传入的主节点地址，和主节点建立连接
2、发送数据复制的指令给主节点，主节点收到指令后，使用bgsave，生成一个RDB文件，并发送给从节点
    从节点接受主节点的RDB文件超时时间默认是60秒，超过会断开连接，从新发送请求，这里可能导致一直重复请求
    生成RDB文件后到从节点接受完该文件期间，主节点收到的新的指令，会放在缓冲区，待从节点接收完文件后在发送给从节点
3、从节点应用RDB文件
4、命令传播

如果从节点和主节点正常连接中，由于某些原因，断开了和主节点的连接，再次连接到主节点时，会根据上次复制的偏移量，继续增量复制
```
- 哨兵机制

```
哨兵节点互相监控，如果一个哨兵发现master节点超过指定时间没有汇报状态，他就会先将master标记为主观下线，然后询问其他哨兵，当大部分哨兵都认为master下线了，才会真正的将master下线
哨兵主节点选举算法：http://thesecretlivesofdata.com/raft/

```

- Redis数据类型

```
Redis使用五大数据类型来表示键和值，每次在Redis数据库中创建一个键值对时，至少会创建两个对象，一个是键对象，一个是值对象，而Redis中的每个对象都是由 redisObject 结构来表示
```
- 缓存雪崩、击穿、穿透

```
缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。

常见解决方案
缓存穿透：直接缓存NULL值、布隆过滤器
缓存击穿：限流(漏桶、令牌桶、滑动时间窗口、计数器)、或者直接使用队列、加锁等、缓存预热
分级缓存：
缓存雪崩：缓存永远不过期+定期刷新机制、缓存时间设置随机、缓存预热
```
