##### JVM
```
-Xmx 设置JVM最大可用内存
-Xms 设置JVM初始化内存,此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存
-Xmn 设置年轻代大小; 增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8
-Xss 设置每个线程的堆栈大小

-XX:NewRatio=4 表示新生代:老年代 = 1:4,意思是老年代占 4/5 
-XX:SurvivorRatio=8 两个Survivor:Eden=2:8,每个Survivor占 1/10
-XX:MetaspaceSize=256m 指Metaspace扩容时触发FullGC的初始化阈值，也是最小的阈值,不设置默认大概20M左右
-XX:MaxMetaspaceSize=512m 设置metaspace区域的最大值
-XX:CMSInitiatingOccupancyFraction=80 设定CMS在对内存占用率达到80%的时候开始GC
-XX:+UseCMSInitiatingOccupancyOnly 只是用设定的回收阈值(上面指定的80%),如果不指定,JVM仅在第一次使用设定值,后续则自动调整
-XX:CMSFullGCsBeforeCompaction=2 上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0
-XX:+CMSParallelRemarkEnabled 开启并行的Remark，加快remark的速度
-XX:+UseFastAccessorMethods 原始类型的快速优化
-XX:+UseConcMarkSweepGC 使用CMS内存收集
-XX:+CMSClassUnloadingEnabled 使用CMS垃圾回收机制的时候是否启用类卸载功能。默认不启用
-XX:+CMSScavengeBeforeRemark 开启或关闭在CMS重新标记阶段之前的清除（YGC）尝试
-XX:+PrintTenuringDistribution 查看每次minor GC后新的存活周期的阈值
-XX:+PrintGCDetails 打印GC详细信息
-XX:+PrintGCDateStamps 打印GC时间 
-XX:PrintGCTimeStamps 打印gc时间戳
-Xloggc:/tmp/gc.log
-XX:+HeapDumpOnOutOfMemoryError 内存溢出时dump出内存信息
-XX:HeapDumpPath=/tmp/heapdump.hprof dump文件位置
-XX:InitiatingHeapOccupancyPercent 堆占用了多少比例的时候触发GC，就即触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%
```


##### 接口的成员特点：   
A:成员变量 只能是常量。默认修饰符 public static final   
B:成员方法 只能是抽象方法。默认修饰符 public abstract

#####   复制效率   
**System.arraycopy>clone>Arrays.copyOf>for循环**    
在System类源码中给出了arraycopy的方法，是native方法，也就是本地方法，肯定是最快的。而Arrays.copyOf(注意是Arrays类，不是Array)的实现，在源码中是调用System.copyOf的，多了一个步骤，肯定就不是最快的。前面几个说System.copyOf的不要看，System类底层根本没有这个方法，自己看看源码就全知道了。

#####    java中访问控制

|访问控制符| 当前类|同一package|子孙类|其他类|
| -------- | -----:|:----:     |:----:|:----:|
| public   | Y     |   Y       |Y     |Y     |
|protected | Y     |   Y       |Y     |N     |
| friendly | Y     |   Y       |N     |N     |
| private  | Y     |   N       |N     |N     |
不写时默认是friendly.

##### Comparable和Comparator的区别
1.  Comparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的
2.  Comparator可以认为是是一个外比较器；   
  优点：  
    1、如果实现类没有实现Comparable接口，又想对两个类进行比较（或者实现类实现了Comparable接口，但是对compareTo方法内的比较算法不满意），那么可以实现Comparator接口，自定义一个比较器，写比较算法   
    2、实现Comparable接口的方式比实现Comparator接口的耦合性 要强一些，如果要修改比较算法，要修改Comparable接口的实现类，而实现Comparator的类是在外部进行比较的，不需要对实现类有任何修改。从这个角度说，其实有些不太好，尤其在我们将实现类的.class文件打成一个.jar文件提供给开发者使用的时候。实际上实现Comparator 接口的方式后面会写到就是一种典型的策略模式。

##### ResultSet中记录行的第一列索引为1

##### Statistic关键字

```
1、父类静态代码块和静态属性 > 子类静态代码块和静态属性 > 父类非静态代码块和属性 > 父类构造函数 > 子类非静态代码块和属性 > 子类构造函数
2、对于静态块和静态属性或者非静态块和属性，初始化顺序决定于它们在代码中的顺序。
3、静态代码块和属性只执行一次，非静态代码块每次调用构造函数都会执行一次
```

##### CurrentHashMap变化

```
初始化参数不是2的N次方，会通过计算得到最近的2的N次方值
JDK1.7 seagment分段锁+数组+链表
JDK1.8 数组+链表+红黑树    数组长度>64 & 链表长度大于8 -> 转换为红黑树，否则，进行数组扩容重新hash，链表长度小于8再转换为链表

JDK8变化：
1、通过数组的方式实现并发增加元素的个数
2、并发扩容 可以多个线程实现并发进行数据的迁移  将数组分成不同的边界
3、通过高低链的方式解决多次hash计算的问题，提升效率 一个数组节点的一条链只用分成高低链，高位链需要迁移，地位链不需要
4、sizeCtl值的三种状态
5、resizeStamp的设计，高低位的设计来实现唯一性以及多个线程的协助扩容记录
```
##### CurrentHashMap中元素个数的维护(分而治之)

```
元素个数：baseCount+ countCell[0 - N]所有value的和
    baseCount：并发量不大的情况下，基于CAS自增，但是只CAS一次，如果一次失败，就用第二种方法(避免并发大的情况下，大量线程CAS循环)
    countCell数组：默认是数组中数据数组长度的两倍，countCell数组的每一个点存储一个voltaile long类型的value指，
操作步骤：每次新增一个值后，都会调用addcount方法，该方法会基于countCell数组的长度生成一个随机数组下标（随机数&数组长度），然后就对countCell[i]使用CAS+1操作，可以有效减轻并发压力

扩容：sizeCtl值
    -1：表示一个占位符，当前已经有线程抢到了初始化数组的权限
    > 0：sizeCtl = sc = n*0.75 = 12 表示下一次扩容大小
    负数，不是-1：表示有几个线程正在对扩容， -2表示有一个
```

##### 阻塞队列

```
新增元素：
   add：添加元素，满了就报错
   offer(可带超时时间)：添加元素，同时返回成功失败
   put：添加元素，满了就阻塞住
删除/获取元素：
   remove：删除
   poll(可带超时时间)：取元素，为空就返回null
   take：取元素，为空就阻塞
```
##### [String类为什么是final](http://blog.csdn.net/u013905744/article/details/52414111)

```
效率：  
1、一个类为final，则该类所有的方法都是final。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。  
安全：
2、不可变性支持线程安全：
多个线程同时读一个资源，是不会引发竟态条件的，不可变对象不能被写，所以线程安全。
3、不可变性支持字符串常量池
大量使用字符串的情况下，可以节省内存空间，提高效率。（多个引用对象指向一个字符串常量池对象）
```
##### String的inner()方法
```
JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。
```

##### 如String s = "ab"，String s1 = "a"; 则String s2 = s1 + "b"是否创建对象？

```
会产生新对象，此处为何没有去常量池查找是否已经存在ab对象，以致于s==s2返回false。因为我们说过常量池是在编译期确定好的，所以如果我们的语句时String s5 = "a"+"b"的话，这个是在编译期确定的，会去常量池查找，而此处我们的语句时s2 = s1+"b"，s2的值只有在运行期才能确定，所以不会去常量池查找，也就是产生新串。那么这里s2的值是在堆、JVM栈还是运行时常量池分配的？正确回答：s2在堆上分配，因为+的内部实现是用StringBuilder来实现的。String s2 = s1+"b" 内部是这样实现的：String s2 = new StringBuilder(s1).append("b").toString();所以是在堆上来分配的
```
##### hashCode和equals()

```
String类重写了Object的equals()，放松了条件，只要对象地址或者内容相等就返回true   
String类重写了hashCode()方法，只要内容相等，则调用hashCode返回的整数值也相等
```

##### 常量池

```
常量池一般就是指字符串常量池，是用来做字符串缓存的一种机制，当我们在程序中写了形如String s = "abc"这样的语句后，JVM会在栈上为我们分配空间，存放变量s和对象”abc“，当我们再次需要abc对象时，如果我们写下：String s1 = "abc"的语句时，JVM会先去常量池中找，如果不存在，则新创建一个对象。如果存在，则直接将s1指向之前的对象”abc“，此时，如果我们用==来判断的话，返回的true。这样做的好处就是节省内存，系统响应的速度加快，（因为省去了对象的创建时间）这也是缓存系统存在的原因。   
常量池是针对在编译期间就确定下来的常量而言的，如上所说的String类的一些对象。但是，当类被加载后，常量池会被搬到方法区的运行时常量池，此时就不再是静态的了，那么是不是就不能向常量池中添加新的内容了呢（因为我们刚刚说过，常量池是在编译期确定好的）？答案是否定的，我们依然可以在运行时向常量池添加内容！这就是我们说过的String类有个方法叫intern()，它可以在运行时将新的常量放于常量池。
```

##### 静态块等加载顺序

```
1、静态块，静态属性->非静态块，属性->构造器
2、对于静态块和静态属性或者非静态块和属性，初始化顺序决定于它们在代码中的顺序。
3、上面三部分。父类的优先于子类
父类的静态代码块和静态属性 》 子类的静态代码块和静态属性 》 父类的非静态代码块和非静态属性、构造器 》 子类的非静态代码块和非静态属性、构造器
```
##### 面相对象-类的理解

```
1、类是一类具有相同属性的事物的统称，是一种抽象。
对象是类的具体体现，又称实例。如人就是一个类，你、我、他是这个类的具体实例，也就是对象。
我们说过Java是面向对象的语言，每个对象都应该拥有它自己的属性和方法，就拿人来说，肤色、身高等是人的属性，吃、喝、玩等都是方法，也就是说属性描绘了类的特点，而方法描述了类的功能
```
##### 重载、重写、隐藏
```
1、重载：是指在同一个类中，具有相同的方法名，不同的参数列表的方法之间的一种机制。参数列表的不同体现在：类型不同、个数不同、顺序不同，满足任一一个，就可以进行方法重载。
2、重写：重写是在继承中存在的，子类重写父类的方法，方法名相同，参数也相同的一种机制。
3、隐藏：当子类和父类方法名相同，参数不同时，子类隐藏父类的方法实现
```
##### 抽象类和接口
```
1、抽象类中是可以没有抽象方法的；有抽象方法的类必须是抽象类；抽象类不一定有实体方法。
2、抽象类只能被继承，不能被实例化！
3、接口：抽象类更加抽象的一种机制；不能提供任何实现，所有方法必须都是抽象的，可以不加abstract关键字，但是编译器对于接口中的方法，都是直接按抽象方法处理的；实现某个接口时，必须重写其所有方法。
```
##### 序列化

```
1. Java 序列化只是针对对象的状态进行保存，至于对象中的方法，序列化不关心
2. 当一个父类实现了序列化，那么子类会自动实现序列化，不需要显示实现序列化接口
3. 当一个对象的实例变量引用了其他对象，序列化这个对象的时候会自动把引用的对象也进行序列化（实现深度克隆）
4. 当某个字段被申明为transient后，默认的序列化机制会忽略这个字段
5. 被申明为 transient的字段，如果需要序列化，可以添加两个私有方法：writeObject 和readObject

问题：
1、Java 序列化机制是Java内部的一种对象编解码技术，无法跨语言使用
2、Java 序列化后的码流太大
3、序列化性能差(CPU 资源占用高)
```
##### java动态代理和Cglib

```
Cglib：
    是继承的方式，选择覆盖父类的方法
    对目标类没有任何的要求
    效率和性能更高、底层没用到反射
    目标代理类不能有final方法，自动忽略final修饰的方法
jdk：
    采用实现的方式，必须要求代理的目标对象一定要实现一个接口
    对用户的依赖性更强，调用那个也更复杂
    生成逻辑较为简单、执行效率比较低，每次都要用哪个反射
   
思想：都是通过生成字节码，重组成一个新的类
```

##### 随机数获取

```
Random 在线程并发的时候会有性能问题以及可能会产生相同的随机数
ThreadLocalRandom.getProbe 可以解决这个问题，并且性能要比 Random 高
```

##### [SPI(service provider interface)](https://github.com/yu757371316/blogs/blob/master/images/JDK%E4%B8%ADSPI%E6%9C%BA%E5%88%B6.png)
```
JDK 内置的一种服务提供发现机制。目前市面上有很多框架都是用它来做服务的扩展发现。简单来说，它是一种动态替换发现的机制。举个简单的例子，我们想在运行时动态给它添加实现，你只需要添加一个实现，然后把新的实现描述给 JDK 知道就行了。的如 JDBC、日志框架都有用到
需要遵循的标准:
1、需要在 classpath下创建一个目录，该目录命名必须是：META-INF/service
2、在该目录下创建一个properties文件，该文件需要满足以下几个条件
a、文件名必须是扩展的接口的全路径名称
b、文件内部描述的是该扩展接口的所有实现类
c、文件的编码格式是 UTF-8
3. 通过 java.util.ServiceLoader 的加载机制来发现
```




