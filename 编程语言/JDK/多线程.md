##### 线程生命周期

```
NEW：使用 new 操作符创建的新的线程对象的初始状态
RUNNABLE：可运行状态，又分为两种
	READY：RUNNING状态的线程 被调度/yield ,线程变为READY
	RUNNING：READY的线程被调度，变成变为RUNNAING
TERMINATED：RUNNABLE的线程执行完毕，一般是run方法中的逻辑执行完毕
BLOCKED：RUNNABLE状态的线程调用同步代码块，拿不到锁的时候
    同步阻塞、等待阻塞(wait)、其他阻塞(sleep、join、IO操作)
WAITING：RUNNABLE状态的线程调用wait、join、LockSupport.park方法的时候
TIME_WAITING：同WAITING，不过是方法中参数带时间，如sleep(时间)
```

##### 线程的中断和复位

```
终止：
thread.interrupt()方法底层是通过设置一个boolean的标志位来标志线程是否应该中断，调用该方法可以将中断标志位设置为true
thread.currentThread.isInterrupt()可以获得底层的中断标志位

重置：
Thread.interrupted()可以使中断标志位复位(回到初始状态false)
中断一个处于阻塞状态(join、wait、sleep、queue.take)的线程，会抛出InterruptedException(相当于系统给了一个停止阻塞线程的入口，可捕获异常处理)
线程抛出InterruptedException也会重置中断标志位
```
[##### 锁升级](https://gitee.com/seeks/blogs/blob/master/images/JDK-%E5%81%8F%E5%90%91%E9%94%81.png)

```
大部分情况下,加锁的代码不仅仅不存在多线程竞争,而且总是由同一个线程多次获得
偏向锁(cas乐观锁-只需一次CAS操作写入ThreadId和偏向锁标识)：只有同一个线程去访问临界区(绝大多时候)；
    目标：减少在无竞争且只有一个线程使用锁的情况下使用轻量锁产生的性能消耗
    过程：cas设置成功则执行同步代码块，失败且获取到偏向锁的线程不是当前线程，则表示其他线程获取到偏向锁,且存在线程竞争,故执行锁升级到轻量级锁
轻量级锁(自旋锁-申请和释放时各需一次CAS操作)：两个线程交替访问临界区(绝大部分线程在获得锁以后，会在非常短的时间内释放)  ->  自旋(线程释放锁很快，一直循环重试，反而效率很高)
    目标：减少无实际竞争情况下使用重量锁产生的性能消耗
	问题：自旋会占用CPU资源，所以在指定的自旋次数后，还没有获得轻量级锁，锁会膨胀成重量级锁 -> 阻塞
	自旋次数：1:设置(preBlockSpin 默认为10) 2:自适应自旋
重量级锁(Mutex)：多个线程同时访问临界区(直接调用objectMonitor的enter和exit，它和操作系统的互斥量直接对应，系统调用会引起用户态和和核心态的切换等问题，性能消耗大。)      阻塞(升级到重量级锁之后，没有获得锁的线程会被阻塞 BLOCKED)
	monitorEnter ------【Monitor】------monitorEnter成功(失败进去SynchronnizedQueue)------获得对象锁 ------ monitorExit
每一个对象都有一个ObjectMonitor,monitor依赖操作系统的MutexLock(互斥锁)来实现的
```

##### 内存一致性
##### 

```
总线锁(锁粒度太大)和缓存锁(缓存一致性协议，最常见的就是 MESI协议)
```

##### 屏障

```
CPU乱序执行 -> 重排序 -> 可见性问题
CPU层提供指令 -> 内存屏障(读屏障、写屏障、全屏障)
通过内存屏障禁止重排序，用来解决可见性问题

```
##### 重排序

```
不管怎么重排序，对于当个线程的执行结果不能变
volatile通过禁止指令重排达到可见性，不解决原子性问题
synchronized 解决原子性、可见性、有序性
```
##### happen-before

```
如果一个操作执行的结果需要对另一个操作可见,那么这两个操作必须要存在happens-before 关系
1、一个线程中的每个操作，happens-before于该线程中的任意后续操作
2、对于volatile修饰的变量的写的操作,一定happen-before后续对于 volatile 变量的读操作
3、传递性规则
4、start规则,主线程在调用子线程start操作之前的任何操作，happens-before子线程中的任何操作
5、join 规则,如果线程A执行操作ThreadB.join()并成功返回，那么线程 B 中的任意操作happens-before于线程A从ThreadB.join()返回
6、监视器锁的规则,对一个锁的解锁,happens-before于随后对这个锁的加锁
```

##### 

```
ReentrantLock：表示重入锁，它是唯一一个实现了 Lock接口的类
ReentrantReadWriteLock：重入读写锁，它实现了 ReadWriteLock 接口，在这个类中维护了两个锁，一个是ReadLock，一个是WriteLock，他们都分别实现了 Lock接口
StampedLock： stampedLock是JDK8引入的新的锁机制，可以简单认为是读写锁的一个改进版本，读写锁虽然通过分离读和写的功能使得读和读之间可以完全并发，但是读和写是有冲突的，如果大量的读线程存在，可能会引起写线程的饥饿。stampedLock是一种乐观的读策略，使得乐观锁完全不会阻塞写线程
```


##### AQS

```
同步队列
AQS 的功能分为两种：独占和共享
AQS 队列内部维护的是一个FIFO的双向链表,这种结构的特点是每个数据结构都有两个指针,分别指向直接的后继节点和直接前驱节点,每个 Node 其实是由线程封装，当线程争抢锁失败后会封装成Node加入到 ASQ 队列中去；当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。
condition队列
五种状态：1(CANCELLED) 0(default) -1(SIGNAL) -2(CONDITION) -3(PROPAGATE)

公平锁与非公平锁：
1、在非公平锁中抢占锁的逻是不管有没有线程排队，我先上来cas去抢占一下,成功就表示成功获得了锁,失败则调用acquire(1)走锁竞争逻辑，而公平锁则不会
2、公平锁 tryAcquire中会判断同步队列中当前节点是否有前驱，有的话，需要等待前驱结点释放锁以后才能获取锁
```

##### Condition

```
阻塞：await()方法中，在线程释放锁资源之后，如果节点不在AQS 等待队列，则阻塞当前线程，如果在等待队列，则自旋等待尝试获取锁
释放：signal()后，节点会从 condition 队列移动到 AQS 等待队列，则进入正常锁的获取流程
```


##### 线程池

```
newCachedThreadPool：可缓存线程池，线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。60S回收
newFixedThreadPool：定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool：定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor：单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

核心都是：
ThreadPoolExecutor(int corePoolSize,     核心线程数
    int maximumPoolSize,                 最大线程数
    long keepAliveTime,                  超时时间
    TimeUnit unit,                       时间单位
    BlockingQueue<Runnable> workQueue,   阻塞队列
    ThreadFactory threadFactory,         线程工厂
    RejectedExecutionHandler handler)    拒绝策略 
```

##### 多线程下单例模式   

```
1、dobble check instance   
2、static inner class
```

