CDN：内容分发网络，将静态资源放到离用户最近的位置  
DNS：域名解析服务

##### HTTP
```
URL：统一资源定位符
格式：schema://host[:port#]/path/.../?[url-params]#[ query-string]
scheme：指定应用层使用的协议(例如:http, https, ftp) host HTTP：服务器的 IP 地址或者域名
port：HTTP 服务器的默认端口是80，这种情况下端口号可以省略。如果使 用了别的端口，必须指明
path：访问资源的路径
query-string：查询字符串
```
##### MIME Type
```
定义：描述消息内容类型的因特网标准
文本文件:text/html,text/plain,text/css,application/xhtml+xml,application/xml
图片文件:image/jpeg,image/gif,image/png.
视频文件:video/mpeg,video/quicktime
可以通过两种方式来设置文件的渲染类型，第一种是 Accept，第二种是 Content-Type
Accept(属于请求头): 表示客户端希望接受的数据类型
Content-Type(属于实体头): 表示发送端发送的实体数据类型
如果 Accept 和 Content-Type 不一致，假如说 Accept 要接收的类型是 image/gif，但是服务 端返回的数据是 text/html，那么浏览器将会无法解析。
```

##### HTTP状态码
```
1XX：信息性状态码；接受的请求正在处理
2XX：请求成功；请求正常处理成功
3XX：重定向状态码；需要附加操作完成请求
4XX：客户端错误；服务器无法处理请求
5XX：服务端错误；服务端处理请求出错
```

##### Http 协议

```
持久连接：HTTP/1.1的Transport段会携带一个Connection:Keep-Alive，持久连接在默认情况下是激活的，除非特别指明，否则HTTP/1.1假定所有的连接都是持久的，要在事务处理结束之后将连接关闭，HTTP/1.1应用程序必须向报文中显示地添加一个Connection:close首部。但是服务端依然能关闭空闲的连接
无状态协议：HTTP协议本身不会对请求和响应之间的通信状态做保存，通过Cookie和Session将应用变为有状态的
```
##### https 安全传输协议

```
原理：加密的超文本传输协议，他和HTTP都是处于TCP传输层之上，只不过在tcp协议层之上增加了一层SSL或者TLS安全层传输协议组合使用用于构造加密通道

CA证书：包括组织、颁发机构、有效期、服务端公钥、唯一证书编号等

前置处理：
1、浏览器和操作系统都会维护一个权威的第三方机构列表(包括他们的公钥)，即根证书
2、服务端生成自己的公私钥，私钥自己保存，将公钥发送给CA机构；CA机构使用自己的私钥对服务端的公钥进行加密，生成CA证书交给服务器

请求过程：
1、客户端发起请求(携带一个随机数)，三次TCP握手；服务端发现是HTTPS请求，将CA证书发送给客户端(返回一个随机数)
2、客户端通过内置的根证书验证服务端证书的合法性
3、证书若为合法，则在生成一个随机数，使用上面的三个随机数生成随机对称秘钥
4、客户端使用CA证书中解密出来的服务端公钥对上面生成的对称秘钥进行加密，并发送给服务端
5、服务端解密，得到客户端生成的随机对称秘钥
6、双方使用对称密钥进行数据的传输
```





##### TCP模型

```
OSI七层网络模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
TCP/IP四层概念模型：应用层(应用层、表示层、会话层)、传输层、网络层、数据链路层(数据链路层、物理层)

应用层(请求内容) ：HTTP请求报文
传输层(传输协议) ：TCP头 + HTTP请求报文
网络层(IP地址) ：IP头 + TCP头 + HTTP请求报文
数据链路层(唯一mac) ：目标机器MAC地址 + IP头 + TCP头 + HTTP请求报文

唯一mac：通过ARP协议(地址解析协议)可以获得IP对应的mac地址，基本思路是，将目标IP广播到网络中，如果某一台机器收到广播发现是自己的IP，就会返回自己的MAC地址
```

##### TCP三次握手
```
含义：指建立一个TCP连接时，需要客户端和服务器总共发送3个包，原因是TCP是全双工协议，需要客户端和服务端都确认连接
过程：
1、客户端发送 SYN 给服务端；同时状态变更 CLOSED -> SYN_SENT(同步已发送)
2、服务端收到 客户端的SYN 请求，发送 SYN+ACK 响应给客户端；同时状态变更 LISTEN(监听) -> SYN_RCVD(同步收到)
3、客户端收到服务端响应，发送接收到响应的确认 ACK；同时状态变更 SYN_SENT(同步已发送) -> ESTAB_LISHED(已建立连接)
4、服务端收到 ACK响应，状态变更 SYN_RCVD(同步已发送) -> ESTAB_LISHED(已建立连接)

```

##### TCP四次挥手
```
含义：指断开一个TCP连接时，需要客户端和服务器总共发送4个包，原因是TCP是全双工协议，客户端和服务端断开连接都要发送一个请求和一个确认
过程：
客户端请求断开单项连接
1、客户端发送 FIN给服务端，表示客户端数据传输完毕，请求断开连接;同时客户端状态变更为 ESTAB_LISHED(已建立连接) -> FIN_WAIT_1(种植等待1)
2、服务端收到客户端断开连接请求，发送 ACK 响应，确认收到请求；同时状态变更为 ESTAB_LISHED(已建立连接) -> CLOSE_WAIT(关闭等待)
3、客户端收到服务端 ACK,变更状态为 FIN_WAIT_1(终止等待1) -> FIN_WAIT_2(终止等待2)

服务端数据传输完毕，确认关闭单向连接
1、服务端发送 FIN 给客户端，表示服务端数据传输完毕，确认断开连接；同时状态变更为 CLOSE_WAIT(关闭等待) -> LAST_ACK(最终确认)
2、客户端收到服务端的 FIN，发送确认报文 ACK 给服务端；同时状态变更为 FIN_WAIT_2(等待确认2) -> TIME_WAIT(时间等待,一般为2MSL(最大报文生存时间))
3、服务端收到客户端的 ACK，状态变更为 LAST_ACK(最后等待) -> CLOSED(关闭状态)

MSL即Maximum Segment Lifetime，就是最大报文生存时间，是任何报文段被丢弃前在网络内的最长存在时间，超过这个时间的报文会被丢弃
```



##### TCP缓冲区

```
发送端：发送数据 -> 发送缓冲区   
接收端：接收缓冲区 -> 接收数据   
缓冲区大小有限制，缓冲区满了会阻塞

[滑动窗口协议](http://www.ccs-labs.org/teaching/rn/animations/gbn_sr/) -> 流量整形

网卡缓冲区 -> 内核缓冲区 -> 用户空间
```

##### IO类型
```
阻塞：服务端accept阻塞   IO读写阻塞
BIO(同步阻塞)：IO读写时交给线程池；客户端发起请求，服务端数据未准备好，则会阻塞住当前线程
NIO(同步非阻塞)：客户端发起请求，服务端数据没准备好，会立即返回一个EWOULDBLOCK，不阻塞客户端线程
```
##### 多路复用模型

```
每一个socket读写对应一个文件描述符fd，
多路复用指的是Socketserver和内核缓冲区之间

Select：fd到内核注册监听，线性轮循，发现一个fd是就绪状态，就通知客户端；默认情况下支持监听的fd个数有限为1024
Poll：
Epoll(伪异步非阻塞)：原理同select，不过不需要轮循，真正基于事件驱动，当fd可读可写时，会直接通知Socketserver来读写数据；监听fd的个数没有限制，只受限于操作系统句柄个数；伪异步是因为Socketserver接收到通知后还是要自己同步的去读取数据

真正的异步应该是注册一个读写事件，操作系统在准备好数据后，将数据从内核读写到用户空间的缓冲区中，而不需要客户端再去内核缓冲区读取数据

同步异步：读写数据是同步还是异步的过程
阻塞非阻塞：发起请求是阻塞还是非阻塞
```



