- [String类为什么是final](http://blog.csdn.net/u013905744/article/details/52414111)

```
效率：  
1、一个类为final，则该类所有的方法都是final。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。  
安全：
2、不可变性支持线程安全：
多个线程同时读一个资源，是不会引发竟态条件的，不可变对象不能被写，所以线程安全。
3、不可变性支持字符串常量池
大量使用字符串的情况下，可以节省内存空间，提高效率。（多个引用对象指向一个字符串常量池对象）
```
- String的inner()方法
```
JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。
```

- 如String s = "ab"，String s1 = "a"; 则String s2 = s1 + "b"是否创建对象？

```
会产生新对象，此处为何没有去常量池查找是否已经存在ab对象，以致于s==s2返回false。因为我们说过常量池是在编译期确定好的，所以如果我们的语句时String s5 = "a"+"b"的话，这个是在编译期确定的，会去常量池查找，而此处我们的语句时s2 = s1+"b"，s2的值只有在运行期才能确定，所以不会去常量池查找，也就是产生新串。那么这里s2的值是在堆、JVM栈还是运行时常量池分配的？正确回答：s2在堆上分配，因为+的内部实现是用StringBuilder来实现的。String s2 = s1+"b" 内部是这样实现的：String s2 = new StringBuilder(s1).append("b").toString();所以是在堆上来分配的
```
- hashCode和equals()

```
String类重写了Object的equals()，放松了条件，只要对象地址或者内容相等就返回true   
String类重写了hashCode()方法，只要内容相等，则调用hashCode返回的整数值也相等
```

- 常量池

```
常量池一般就是指字符串常量池，是用来做字符串缓存的一种机制，当我们在程序中写了形如String s = "abc"这样的语句后，JVM会在栈上为我们分配空间，存放变量s和对象”abc“，当我们再次需要abc对象时，如果我们写下：String s1 = "abc"的语句时，JVM会先去常量池中找，如果不存在，则新创建一个对象。如果存在，则直接将s1指向之前的对象”abc“，此时，如果我们用==来判断的话，返回的true。这样做的好处就是节省内存，系统响应的速度加快，（因为省去了对象的创建时间）这也是缓存系统存在的原因。   
常量池是针对在编译期间就确定下来的常量而言的，如上所说的String类的一些对象。但是，当类被加载后，常量池会被搬到方法区的运行时常量池，此时就不再是静态的了，那么是不是就不能向常量池中添加新的内容了呢（因为我们刚刚说过，常量池是在编译期确定好的）？答案是否定的，我们依然可以在运行时向常量池添加内容！这就是我们说过的String类有个方法叫intern()，它可以在运行时将新的常量放于常量池。
```

- 静态块等加载顺序

```
1、静态块，静态属性->非静态块，属性->构造器
2、对于静态块和静态属性或者非静态块和属性，初始化顺序决定于它们在代码中的顺序。
3、上面三部分。父类的优先于子类
父类的静态代码块和静态属性 》 子类的静态代码块和静态属性 》 父类的非静态代码块和非静态属性、构造器 》 子类的非静态代码块和非静态属性、构造器
```
- 面相对象-类的理解

```
1、类是一类具有相同属性的事物的统称，是一种抽象。
对象是类的具体体现，又称实例。如人就是一个类，你、我、他是这个类的具体实例，也就是对象。
我们说过Java是面向对象的语言，每个对象都应该拥有它自己的属性和方法，就拿人来说，肤色、身高等是人的属性，吃、喝、玩等都是方法，也就是说属性描绘了类的特点，而方法描述了类的功能
```
- 重载、重写、隐藏
```
1、重载：是指在同一个类中，具有相同的方法名，不同的参数列表的方法之间的一种机制。参数列表的不同体现在：类型不同、个数不同、顺序不同，满足任一一个，就可以进行方法重载。
2、重写：重写是在继承中存在的，子类重写父类的方法，方法名相同，参数也相同的一种机制。
3、隐藏：当子类和父类方法名相同，参数不同时，子类隐藏父类的方法实现
```
- 抽象类和接口
```
1、抽象类中是可以没有抽象方法的；有抽象方法的类必须是抽象类；抽象类不一定有实体方法。
2、抽象类只能被继承，不能被实例化！
3、接口：抽象类更加抽象的一种机制；不能提供任何实现，所有方法必须都是抽象的，可以不加abstract关键字，但是编译器对于接口中的方法，都是直接按抽象方法处理的；实现某个接口时，必须重写其所有方法。
```
- 图的遍历

```
图的遍历是从给定的源点出发，每一个顶点仅被访问一次。遍历的基本算法有两种：深度遍历DFS和广度遍历BFS，基于递归实现，并且都适用于有向图和无向图
```
- 线性结构和非线性结构

```
线性结构：有序数据元素的集合。中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的；
常用的线性结构有：线性表，栈，队列，双队列，数组，串。
非线性结构：每个数据元素可能与零个或者多个其他数据元素发生联系
常见的非线性结构有：二维数组，多维数组（多个一维数组组成），广义表，树(二叉树等)，图
```

- 多线程下单例模式   

```
1、dobble check instance   
2、static inner class
```
- 注解






